package passive;

// This represents a single trace collected by bismark-passive. Routers write
// one trace every 30 seconds by default.
message Trace {
  // There are currently 5 file format versions of trace files. This protocol
  // buffer definition is compatible with all versions, although certain fields
  // are left blank with older format versions and the semantics of some fields
  // might slightly change between versions.
  //
  // A brief summary of versions:
  // Version 1 was the first version.
  // Version 2 allocated the first few flow IDs to denote non-IP protocols and
  // added a new section with statistics about dropped packets.
  // Version 3 added optional anonymization of CNAMEs, so CNAMEs and domains
  // could be anonymized separately.
  // Version 4 fixed a formatted bug in the dropped packets section.
  // Version 5 fixed a bug where DNS entries might refer to invalid packets when
  // the packet table is full.
  optional int32 file_format_version = 1;

  // An identifier for the version of the bismark-passive executable that
  // generated the trace, or "UNKNOWN" if no such identifier is available.  We
  // only used this feature in a few early builds, so it will be "UNKNOWN" in
  // the vast majority of cases.
  optional string build_id = 2;

  // The Bismark router ID of the router that collected this trace. This
  // is simply the contents of /etc/bismark/ID on the router.
  // Example: OW0123456789AB
  optional string node_id = 3;

  // The time the process started on the router in microseconds since epoch.
  // Time is taken according to the router's clock. Clocks occasionally fail to
  // sync so this might be wildly inaccurate. (e.g., near January 1, 1970)
  //
  // This serves as a unique identifier of the process that generated the
  // trace on a given router.
  //
  // To truly uniquely identify a bismark-passive process we should also record
  // the PID, but if two instances of bismark-passive are ever running we have
  // bigger problems to worry about.
  optional int64 process_start_time_microseconds = 4;

  // The sequence number increments from 0 for each trace generated by a
  // bismark-passive process. Sequence numbers restart from zero when
  // bismark-passive restarts.
  optional int32 sequence_number = 5;

  // The timestamp when the trace was created, in seconds since 1970, according
  // to the router's clock. Note that a trace is for the ~30 seconds prior to
  // this timestamp; this timestamp *does not* indicate the beginning of the
  // trace's data.
  optional int64 trace_creation_timestamp = 6;

  // Statistics about the number of packets received or dropped by PCAP and the
  // network interface.
  optional uint32 pcap_received = 7;
  optional uint32 pcap_dropped = 8;
  optional uint32 interface_dropped = 9;

  // A list of (sub)domains the user wants to be whitelisted in this session.
  // This will only be non-empty if sequence_number = 0.
  repeated string whitelist = 10;

  // A hash of the key used to anonymize sensitive data collected on the router.
  // This field will be unset if no key was used and data was not anonymized.
  optional string anonymization_signature = 11;

  // The number of packets dropped from packet_series because it filled up.
  optional uint32 packet_series_dropped = 12;
  // The timestamp, size, and flow ID of every packet since the last trace.
  repeated PacketSeriesEntry packet_series = 13;

  // The baseline timestamp used by the flow table during this collection period
  // in number of seconds since epoch. The client uses the baseline timestamp to
  // expire old flows; it is of no use on the server, but we collect it anyway
  // since it could help debug problems with flow expiration.
  optional int64 flow_table_baseline = 14;
  // The size of the flow hashtable. The maximum number of flows in the table
  // can be far lower due to hash collisions.
  optional uint32 flow_table_size = 15;
  // The number of flow table entries we expired during this collection period.
  // We only increment this counter when a new flow collides with an expired
  // flow in the hash table.
  optional int32 flow_table_expired = 16;
  // The number of flows dropped from the flow table during this collection
  // period. We drop a flow if we can't find an open slot in the hash table with
  // 3 probes in the open-addressed hash table.
  optional int32 flow_table_dropped = 17;
  // A list of flow table entries created since the last trace.
  repeated FlowTableEntry flow_table_entry = 18;

  // The number of A records we dropped. Unlike the flow table, we store DNS
  // records in a list and only drop records when the list is full.
  optional int32 a_records_dropped = 19;
  // The list of DNS A records found in DNS response packets. Note that
  // there can be several A and CNAME records in one DNS response packet.
  repeated DnsARecord a_record = 20;
  optional int32 cname_records_dropped = 21;
  // The list of DNS CNAME records found in DNS response packets.
  repeated DnsCnameRecord cname_record = 22;

  // We store address table entries in a circular buffer on the client and
  // flatten that buffer when sending it to the server. This field records the
  // index into the circular buffer we chose as index 0 in the flattened
  // representation.
  //
  // The address_id fields in the DNS tables use indices from the circular
  // buffer, so you need to use this field to calculate the correct offset into
  // the flattened representation.
  optional int32 address_table_first_id = 23;
  // The number of entries in the address table. This indicates when we should
  // wrap IDs from the circular buffer when converting from the flattened
  // representation.
  optional int32 address_table_size = 24;
  // A list of address table entries created since the last trace.
  repeated AddressTableEntry address_table_entry = 25;

  // Information about the sizes of dropped packets.
  repeated DroppedPacketsEntry dropped_packets_entry = 26;
}

// There will be once instance of this message type for each packet recorded by
// bismark-passive.
message PacketSeriesEntry {
  // Timestamp in microseconds since January 1, 1970.
  optional int64 timestamp_microseconds = 1;
  // The size of the packet in bytes.
  optional int32 size = 2;
  // The flow ID of the packet, or -1 if there is no flow ID.  bismark-passive
  // reserves certain flow IDs to indicate non-IP protocols.  See
  // src/constants.h in the bismark-passive source code.
  optional int32 flow_id = 3;
}

// A flow 5-tuple. Flows are unidirectional, so typically there will be two
// flows per TCP connection (unless one is dropped from the flow table.)
message FlowTableEntry {
  // The flow's index in the flow hash table on the bismark-passive client.
  optional int32 flow_id = 1;
  // IP are always anonymized after January 2011.
  optional bool source_ip_anonymized = 2;
  optional string source_ip = 3;
  // IP are always anonymized after January 2011.
  optional bool destination_ip_anonymized = 4;
  optional string destination_ip = 5;
  // See http://www.iana.org/assignments/protocol-numbers/protocol-numbers.txt
  optional int32 transport_protocol = 6;
  optional int32 source_port = 7;
  optional int32 destination_port = 8;
}

// An A record parsed from a DNS response packet.
message DnsARecord {
  // An index into the packet series table.
  optional int32 packet_id = 1;
  // An index into the address table.
  optional int32 address_id = 2;
  // Whether the domain is anonymized.
  optional bool anonymized = 3;
  // Full domain name, which might be anonymized.
  optional string domain = 4;
  // The IP address, which is always anonymized.
  optional string ip_address = 5;
  // The TTL of the record in seconds.
  optional int32 ttl = 6;
}

// An CNAME record parsed from a DNS response packet.
message DnsCnameRecord {
  // An index into the packet series table.
  optional int32 packet_id = 1;
  // An index into the address table.
  optional int32 address_id = 2;
  // Whether the domain is anonymized.
  optional bool domain_anonymized = 3;
  // The domain name, which might be anonymized.
  optional string domain = 4;
  // Whether the CNAME is anonymized.
  optional bool cname_anonymized = 5;
  // The CNAME, which might be anonymized.
  optional string cname = 6;
  // The TTL of the record in seconds.
  optional int32 ttl = 7;
}

message AddressTableEntry {
  // The anonymized MAC address of a client device.
  optional string mac_address = 1;
  // The anonymized IP address of a client device.
  optional string ip_address = 2;
}

// Record the number of packets dropped of a certain size.
message DroppedPacketsEntry {
  optional uint32 size = 1;
  optional uint32 count = 2;
}

